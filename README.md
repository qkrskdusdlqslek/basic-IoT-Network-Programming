# basic-IoT-Network-Programming
IoT 개발자과정 블루투스 리포지토리

## 1일차
- TCP/IP -> cmd(명령 프롬포트)> ipconfig

- 전송방식 
    - TCP / UDP
    - TCP : 데이터를 잃어버리면 안되는 것(ex. 압축파일)
    - UDP : 데이터를 한두개 잃어버려도 되는 것 (ex. 영화 파일)

- 소.말.리.아. -> 소켓(socket), 바인더(bind), 리슨(listen), 엑셉트(accept)
    - 소켓 : 휴대폰을 고르는 것
    - 바인더 : 휴대폰 개통을 위해 개인정보와 전화번호가 필요함(할당)
    - 리슨 : 휴대폰 개통
    - 엑셉트 : 통화 버튼 누르고 통화하는 것

- Putty 사용법(192.168.5.3)
    - 아이디 : pi / 비번 : raspi

    ![Putty 실행화면](https://raw.githubusercontent.com/qkrskdusdlqslek/basic-IoT-Network-Programming/main/images/Putty.png)

    ![Putty 실행화면](https://raw.githubusercontent.com/qkrskdusdlqslek/basic-IoT-Network-Programming/main/images/Putty2.png)

- 리눅스 기반 파일 조작
    - 파일 디스크립터
        - 0 : 표준입력(Standard Input)
        - 1 : 표준출력(Standard Output)
        - 2 : 표준에러(Standard Error)

- 프로토콜 
    - 컴퓨터 상호간의 대화에 필요한 통신규약

- 소켓 타입
    - 연결지향형 소켓(TCP) / 비 연결지향형 소켓(UDP)

- 클래스 별 네트워크 주소와 호스트 주소의 경계
    - 클래스 A의 첫번째 바이트 범위 : 0이상 127이하 (0000 0000 ~ 0111 1111)
    - 클래스 B의 첫번째 바이트 범위 : 128이상 191이하 (1000 0000 ~ 1011 1111)
    - 클래스 C의 첫번째 바이트 범위 : 192이상 223이하 (1100 0000 ~ 1101 0010)
        - 포트번호 겹치면 안됨.

- 주소 정보의 표현
    - 구조체 sockaddr_in의 분석
        - AF_INET = PF_INET : IPv4 인터넷 프로토콜에 적용하는 주소체계
    - 바이트 순서와 네트워크 바이트 순서
        - 빅 엔디안 : 상위 바이트의 값을 작은 번지수에 저장
        - 리틀 엔디안 : 상위 바이트의 값을 큰 번지수에 저장

## 2일차
- 인터넷 주소의 초기화
```
    struct sockaddr_in addr;  // IP주소 문자열 선언
    char *serv_ip="211.217.168.13; // PORT번호 문자열 선언
    char *serv_port="9190" // 구조체 변수 addr의 모든 멤버 0으로 초기화
    memset(&addr, 0, sizeof(addr)) // 구조체 변수 addr의 모든 멤버 0으로 초기화
    addr.sin_family=AF_INET // 주소체계 지정
    addr.sin_addr.s_addr=inet_addr(serv_ip_) // 문자열 기반의 IP주소 초기화
    addr.sin_port=htons(atoi(serv_port)) // 문자열 기반의 PORT번호 초기화
```
- memset 함수는 동일한 값으로 바이트단위 초기화를 할 때 호출
- addr을 전부 0으로 초기화 하는 이유는, 0으로 초기화해야 하는 sockaddr_in 구조체 멤버 sin_zero를 0으로 초기화 하기 위함.

- bind(함수)
    - 초기화된 주소정보를 소켓에 할당

- LINK 계층
    - 물리적인 영역의 표준화에 대한 결과    
    - 네트워크 표준과 관련된 프로토콜을 정의하는 영역

- IP 계층 (비 연결지향적)
    - 복잡하게 연결되어 있는 인터넷을 통한 데이터의 전송을 위해 어떤 경로를 거쳐갈 것인가의 문제를 해결하는 계층
    - 프로토콜(오류발생에 대한 대비가 X)

- TCP/UDP 계층
    - IP 계층에서 알려준 경로정보를 바탕으로 데이터의 실제 송수신을 담당
    - UDP는 TCP에 비해 상대적으로 간단함
    - TCP는 신뢰성 있는 데이터의 전송 담당 / 확인절차를 통해 응답을 받아 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜

- TCP(신뢰성 전송방식)
    - TCP 서버의 함수호출 순서
        - **socket() 소켓생성 -> bind() 소켓 주소할당 -> listen() 연결요청 대기상태 -> accept() 연결허용 -> read()/write() 데이터 송수신 -> close()         연결종료**

    - TCP 클라이언트 함수호출 순서
        - **socket() -> connect() -> read()/write() -> close()**

    - accept(함수)
        - '연결요청 대기 큐'에서 대기중인 클라이언트의 연결요청을 수락하는 기능
        - 내부적으로 데이터 입출력에 사용할 소켓 생성
        - 소켓의 파일 디스크립터를 반환
        - 소켓이 자동으로 생성되어, 연결요청을 한 클라이언트 소켓에 연결까지 이뤄짐

    - TCP 소켓에 존재하는 입출력 버퍼
        - 입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재함
        - 입출력 버퍼는 소켓생성시 자동으로 생성됨
        - 소켓을 닫아도 출력버퍼에 남아있는 데이터는 계속해서 전송이 이뤄짐
        - 소켓을 닫으면 입력버퍼에 남아있는 데이터는 소멸됨

- UDP(빠른 전송방식)
    - TCP보다 훨씬 간결한 구조로 설계되어 있음
    - TCP는 신뢰성이 없는 IP를 기반으로 신뢰성 있는 데이터의 송수신을 위해 '흐름제어'를 하지만, UDP는 '흐름제어'가 없음
    - 호스트로 수신된 패킷을 PORT 정보를 참조해 최종 목적지인 UDP 소켓에 전달
    - 서버와 클라이언트는 연결되어 있지 않음
    - 서버건 클라이언트건 하나의 소켓만 있으면 됨

## 3일차
- 연결종료
    - 리눅스의 clsoe 함수호출과 윈도우의 clsoesocket 함수호출은 완전종료를 의미함
    - 완전종료는 데이터 전송, 수신 등이 더 이상 불가능한 상황을 의미함
    - 완전종료의 문제를 해결하기 위해서 데이터의 송수신에 사용되는 스트림의 일부만 종료(Half-close)하는 방법 제공

    - 소켓과 스트림
        - 소켓을 통해 두 호스트가 연결되면, 상호간에 데이터 송수신이 가능한 상태를 **스트림이 형성된 상태**라고 함
    
    - shutdown 함수
        - 스트림의 일부를 종료할 때 사용되는 함수

- Domain Name System
    - 도메인 이름   
        - 기억하기 좋고 표현하기 좋은 형태의 도메인 이름을 IP주소에 부여해 IP주소를 대신함
    
    - DNS 서버
        - 도메인 이름을 IP주소 변환을 담당하는 것
        - 도메인 이름은 해당 서버에 부여된 가상 주소(실제 주소X)
        - 가상 주소를 실제 주소로 변환하는 과정을 거쳐 네이버에 접속해야 함(DNS 서버)

- 소켓의 다양한 옵션
    - 소켓의 옵션은 계층별로 분류됨
        - SOL_SOCKET / IPPROTO_IP / IPPROTO_TCP
    
- 프로세스의 이해와 활용
    - 다중접속 서버의 구현방법
        - 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공
        - 멀티플렉싱 기반 서버 : 입출력 대상을 묶어 관리하는 방식으로 서비스 제공
        - 멀티쓰레딩 기반 서버 : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공
    
    - 프로세스
        - 메모리 공간을 차지한 상태에서 실행중인 프로그램 (현재 실행되고 있는 프로그램)

    - 프로세스 ID
        -  모든 프로세스는 생성되는 형태에 상관없이 운영체제로부터 부여받은 ID

    - fork 함수호출
        ```
        #include <unistd.h>

        pid_t fork(void);
        -> 성공 시 프로세스 ID, 실패 시 -1 반환
        ```
        - 호출한 프로세스의 복사본 생성
        - 전혀 새로운 다른 프로그램을 바탕으로 프로세스를 생성하는 것이 아닌 이미 실행중인, fork 함수를 호출한 프로세스를 복사한 것.
        - 부모 프로세스(원본 프로세스 , fork 함수를 호출한 주체) -> fork 함수의 반환 값은 자식 프로세스의 ID
        - 자식 프로세스(복사된 프로세스) -> fork 함수의 반환 값은 0

    - 좀비 프로세스
        - 프로세스가 생성되고 main 함수의 실행을 완료하면 사라져야 하는데 사라지지 않고 좀비가 되어 시스템의 중요한 리소스를 차지하고 있는 상태

## 4일차
- 좀비 프로세스 소멸
    - wait 함수
        - WIFEXITED : 자식 프로세스가 정상 종료한 경우 '참(true)'을 반환
        - WEXITSTATUS : 자식 프로세스의 전달 값을 반환
        - 호출된 시점에서 종료된 자식 프로세스가 없다면, 임의의 자식 프로세스가 종료될 때까지 **블로킹 상태**에 놓인다(주의!)

    - waitpid 함수(블로킹 문제의 해결책)
        
    - 시그널 핸들링
        - 시그널은 특정상황이 발생했음을 알리기 위해 운영체제가 프로세스에게 전달하는 메시지를 의미
        - 핸들링은 그 메시지에 반응해서 메시지와 연관된, 미리 정의된 작업이 진행되는 것을 의미

    - signal 함수
        - 프로세스는 자식 프로세스의 종료라는 상황 발생 시, 특정 함수 호출을 운영체제에게 요구함(시그널 등록 함수)
        ```
            #include <signal.h>
            
            void(*signal(int_signo, void (*func)(int)))(int);

            -> 시그널 발생시 호출되도록 이전에 등록된 함수 포인터 반환
        ```
        - SIGALRM : alarm 함수호출을 통해 등록된 시간이 된 상황
        - SIGINT : CTRL+C가 입력된 상황
        - SIGCHILD : 자식 프로세스가 종료된 상황

    - sigaction 함수
        - signal 함수 대체 가능, signal 함수보다 훨씬 안정적으로 동작함
        - signal 함수는 유닉스 계열의 운영체제 별로 동작방식에 있어 약간의 차이가 있지만, sigaction 함수는 차이가 X

- 멀티태스킹 기반의 다중접속 서버
    - 에코 서버 확장(동시에 둘 이상의 클라이언트에게 서비스 제공)

- 프로세스간 통신
    - 파이프(PIPE) 기반
        - 운영체제에 속하는 자원인 파이프 생성(프로세스에 속하는 자원X)
        - 운영체제가 마련해 주는 메모리 공간을 통해 통신
    
    - 에코 서버(메시지를 저장하는 형태)
        - 서버는 클라이언트가 전송하는 문자열이 전달되는 순서대로 파일에 저장

- IO 멀티플렉싱
    - 하나의 통신채널을 통해서 둘 이상의 데이터를 전송하는데 사용되는 기술
    - 물리적 장치의 효율성을 높이기 위해 최소한의 물리적인 요소만 사용해서 최대한의 데이터를 전달하기 위해 사용되는 기술

    - select 함수
        - 한곳에 여러 개의 파일 디스크립터를 모아놓고 동시에 관찰 가능

## 5일차
- 입출력 함수
    - send & recv 함수
    ```
    MSG_OOB : 긴급 데이터(Out of band)의 전송을 위한 옵션 -> 긴급 메시지의 전송
    MSG_DONTWAIT : 입출력 함수 호출과정에서 블로킹 되지 않을 것을 요구하기 위한 옵션
    MSG_PEEK : 입력버퍼에 수신된 데이터의 존재유무 확인을 위한 옵션(recv)
    MSG_DONTROUTE :  데이터 전송과정에서 라우팅 테이블을 참조하지 않을 것을 요구하는 옵션, 로컬 네트워크상에서 목적지 찾을 때(send)
    MSG_WAITALL : 요청한 바이트 수에 해당하는 데이터가 전부 수신될 때까지, 호출된 함수가 반환되는 것을 막기 위한 옵션(recv)
    ```
    - readv & writev 함수
        - 데이터를 모아서 전송하고, 모아서 수신하는 기능의 함수

- 소켓과 표준 입출력
    - 표준 입출력 함수의 장점
        - 표준 입출력 함수는 이식성(Portability)이 좋다.
        - 표준 입출력 함수는 버퍼링을 통한 성능의 향상에 도움이 된다.

    - 표준 입출력 함수의 단점
        - 양방향 통신이 쉽지 않음.
        - 상황에 따라서 fflush 함수의 호출이 빈번히 등장할 수 있음.
        - 파일 디스크립터를 FILE 구조체의 포인터를 변환해야 함.

    - fdopen 함수, fileno 함수

- 입출력 스트림의 분리..
    - 파일 디스크립터의 복사 & Half-close
        - fork(멀티프로세스) 함수호출에서 진행되는 복사와는 다른 의미.
        - 프로세스의 생성을 동반하지 않는, 원본과 복사본이 하나의 프로세스 내에 존재하는 형태의 복사를 뜻함
        - 동일한 파일 또는 소켓의 접근을 위한 또 다른 파일 디스크립터의 생성

    - 파일 디스크립터 복사 함수
        - dup 함수 
        - dup2 함수 : 복사된 파일 디스크립터의 정수 값을 명시적으로 지정할 때 사용

## 6일차
- epoll(리눅스 기반, 윈도우X)
    - 멀티플렉싱 기법 
    - select보다 나은 방법
    
    - epoll_ctl
        - epoll 인스턴스 생성 후에 관찰대상이 되는 파일 디스크립터 등록 함수
        ```
            EPOLL_CTL_ADD : 파일 디스크립터를 epoll 인스턴스에 등록
            EPOLL_CTL_DEL : 파일 디스크립터를 epoll 인스턴스에서 삭제
            EPOLL_CTL_MOD : 등록된 파일 디스크립터의 이벤트 발생상황을 변경
        ```

- 멀티쓰레드 기반의 서버구현
    - 쓰레드와 프로세스 차이점
        - 프로세스의 메모리 구조는 전역변수가 할당되는  데이터 영역, malloc함수 등에 의해 동적 할당이 이뤄지는 힙 그리고 실행에 사용되는 스택으로 이뤄짐
        - 쓰레드는 별도의 실행흐름을 유지하기 위해서 스택 영역만 독립적으로 유지
        ```
            프로세스 : 운영체제 관점에서 별도의 실행흐름을 구성하는 단위
            쓰레드 : 프로세스 관점에서 별도의 실행흐름을 구성하는 단위
        ```

    - 쓰레드
        - main 함수를 별도로 정의
        
    - 쓰레드 동기화
        - 쓰레드의 접근순서 때문에 발생하는 문제점의 해결책
        - 동일한 메모리 영역으로의 동시접근이 발생하는 상황
        - 동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야 하는 상황
    
    - 뮤텍스
        - 쓰레드의 동기접근에 대한 해결책
        - lock | unlock

    - 세마포어
        - 0과 1만 사용
        - 두 개의 원자적 함수로 조작되는 정수 변수로서, 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법으로 사용
        
    - 쓰레드 소멸
        - pthread_join 함수 호출
        - pthread_detach 함수 호출

## 7일차
- 

        
        
        





